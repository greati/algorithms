\documentclass{article}
\usepackage{authblk}
\usepackage{listings}


\begin{document}

\title{Dynamic Programming}
\author{Vitor R. Greati\thanks{greati@ufrn.edu.br || vitorgreati.me}}
\date{January, 2016}

\maketitle

\section{Introduction}
Like the divide-and-conquer approach, DP divides into subproblems and combines its solutions.
The difference is that subproblems overlap in DP, which means that they share subproblems.
A divide-and-conquer approach would do moe work than necessary, solving repeatdly times
same subproblems. The DP way consists of solving subproblems and keeping the solutions
in a table, so that they can be reused, avoiding recalculations.

DP is commonly applied in \textbf{optimization problems}, which are concerned in obtaining
maximum or minimum solutions among various (we want an optimal, not the optimal). 

\section{Examples}

\subsection{}

\subsection{(TopCoder) Coins to compound a sum}
We have the following problem:

\emph{Given a list of $N$ coins, their values $\(V_1, V_2, \ldots, V_N)$, and the total sum $S$. Find the minimum number of coins the sum of which is $S$ (we can use as many coins of one type as we want), or report that itâ€™s not possible to select coins in such a way that they sum up to $S$.}

\subsubsection{Finding a state}

A state is a way to describe a situation representing a sub-solution for the problem. For example,
if we want to find a solution for sum $i \le S$, this would be a state for $i$. A smaller state
than $i$ would be a solution for any $j < i$. For finding a state for $i$, it's necessary to
find all states for all $j < i$. Once found for $i$, it's easy to find for $i + 1$, until
$i + 1$.



\end{document}
